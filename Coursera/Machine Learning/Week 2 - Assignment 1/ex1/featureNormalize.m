function [X_norm, mu, sigma] = featureNormalize(X)
%FEATURENORMALIZE Normalizes the features in X
%   FEATURENORMALIZE(X) returns a normalized version of X where
%   the mean value of each feature is 0 and the standard deviation
%   is 1. This is often a good preprocessing step to do when
%   working with learning algorithms.

% You need to set these values correctly
X_norm = X;
mu = zeros(1, size(X, 2));
sigma = zeros(1, size(X, 2));

% ====================== YOUR CODE HERE ======================
% Instructions: First, for each feature dimension, compute the mean
%               of the feature and subtract it from the dataset,
%               storing the mean value in mu. Next, compute the
%               standard deviation of each feature and divide
%               each feature by it's standard deviation, storing
%               the standard deviation in sigma.
%
%               Note that X is a matrix where each column is a
%               feature and each row is an example. You need
%               to perform the normalization separately for
%               each feature.
%
% Hint: You might find the 'mean' and 'std' functions useful.
%
dimsX = size(X); % dimsX(1) == # rows, dimsX(2) == # cols
mu = mean(X,1)
sigma = std(X,1)

% The below solution is broken up into two steps. The first part involves
% removing the oppropriate mean from each column. To do this, each mean is
% placed into an m x 2 matrix, where either the first or second column is zeroed
% out and the appropriate mean is in the other column. This is done for each
% mean. Second, after the mean has been removed, the standard deviation must be
% used to normalize the data. So, again, a zero value is placed in one of the
% arrays used to multiply X - \mu. The nonzero value is the inverse of the
% standard deviation of one of the columns. The dot product of this array (which
% has only one nonzero value, the standard deviation) is taken with each row of
% X. This forms an m x 1 array. This is concatenated with the other m x 1 array
% generated by considering the second standard deviation. Actually, I just
% realized that I should generalize this in case there are more than two
% columns. So, I will put this vectorized code into a for loop to allow for as
% many columns as might exist.
for i = 1 : dimsX(1,2)
   % Work on one column of X_norm. Then replace that column of X_norm with this
   % one.
   X_norm(:,i) = (X(:,i)-mu(1,i))/sigma(1,i);
endfor
% ============================================================

%disp('After normalization:');
%fprintf(' X_norm = [%2.4f %2.4f] \t X = [%4.8f %4.8f] \n', [X_norm(1:10,:) X(1:10,:)]');
%
%plot(X_norm(:,1),X_norm(:,2),'xo')

end
